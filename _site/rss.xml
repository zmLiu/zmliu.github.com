<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>zmLiu</title>
        <description>zmLiu - zmLiu</description>
        <link>http://zmliu.github.io</link>
        <link>http://zmliu.github.io</link>
        <lastBuildDate>2014-04-12T12:22:00+08:00</lastBuildDate>
        <pubDate>2014-04-12T12:22:00+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>StarlingSwf贡献</title>
                <description>&lt;h2 id='id76'&gt;贡献榜&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;StarlingSwf发布以来，得到很多热朋友的建议和支持，驱动着StarlingSwf的不断完善和强大，在此特别感谢。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;可以加QQ群168436154，也可以直接联系我QQ:470301594&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主要依据：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
 	&lt;li&gt;优秀建议者&lt;/li&gt;
 	&lt;li&gt;StarlingSwf代码贡献者&lt;/li&gt;
 	&lt;li&gt;StarlingSwf文档贡献者&lt;/li&gt;
 	&lt;li&gt;StarlingSwf教程贡献者&lt;/li&gt;
 	&lt;li&gt;资金支持者&lt;/li&gt;
 &lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;捐助StarlingSwf&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id='id77'&gt;&lt;a href='https://me.alipay.com/starlingswf/' target='_blank'&gt;点击这里捐助StarlingSwf&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;贡献榜&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;root.z&lt;/strong&gt; &amp;#160;&amp;#160;&amp;#160; &lt;strong&gt;吃心勒菠萝اللغة&lt;/strong&gt; &amp;#160;&amp;#160;&amp;#160; &lt;strong&gt;jiessie&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;flash_html5&lt;/strong&gt; &amp;#160;&amp;#160;&amp;#160; &lt;strong&gt;小四&lt;/strong&gt; &amp;#160;&amp;#160;&amp;#160; &lt;strong&gt;胡业坚&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;王仁文&lt;/strong&gt; &amp;#160;&amp;#160;&amp;#160;&lt;/p&gt;</description>
                <link>http://zmliu.github.io/2014/04/12/StarlingSwf-Donate</link>
                <guid>http://zmliu.github.io/2014/04/12/StarlingSwf-Donate</guid>
                <pubDate>2014-04-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>StarlingSwf 粒子集成</title>
                <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;有些同学使用过程用遇到了问题。我开了一个QQ群。有问题的同学可以进来问一下群号是168436154&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://zmliu.github.io/2013/11/09/StarlingSwfTool/'&gt;StarlingSwf&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='starling_'&gt;关于Starling的粒子 我这里就不多讲了&lt;/h4&gt;

&lt;h1 id='id74'&gt;教程&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.准备粒子的文件&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://onebyonedesign.com/flash/particleeditor/'&gt;粒子编辑器&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://wiki.starling-framework.org/extensions/particlesystem'&gt;官方页面&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过编辑器。可以得到粒子的xml以及粒子需要的texture。怎么使用我就不多讲了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.创建粒子元件&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;StarlingSwf中 粒子由两个部分组成&lt;/p&gt;

&lt;p&gt;a.粒子的纹理img&lt;/p&gt;

&lt;p&gt;b.一个文本，文本上填写粒子的xml&lt;/p&gt;

&lt;p&gt;如图:&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_particle/image1.png' /&gt;
&lt;p&gt;最后导出Swf到工具中预览就行。&lt;/p&gt;</description>
                <link>http://zmliu.github.io/2014/03/27/StarlingSwf-Particle</link>
                <guid>http://zmliu.github.io/2014/03/27/StarlingSwf-Particle</guid>
                <pubDate>2014-03-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>MySql数据库索引优化注意事项</title>
                <description>&lt;p&gt;设计好MySql的索引可以让你的数据库飞起来，大大的提高数据库效率。设计MySql索引的时候有一下几点注意：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;创建索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;复合索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;

如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age, salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;索引不会包含有NULL值的列&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;使用短索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;排序的索引问题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;like语句操作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;不要在列上进行运算&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;select * from users where YEAR(adddate)&amp;lt;2007;将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成select * from users where adddate&amp;lt;‘2007-01-01’;&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;不使用NOT IN和&amp;lt;&amp;gt;操作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;NOT IN和&amp;lt;&amp;gt;操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id&amp;lt;&amp;gt;3则可使用id&amp;gt;3 or id&amp;lt;3来代替。&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://zmliu.github.io/2014/02/10/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9</link>
                <guid>http://zmliu.github.io/2014/02/10/MySql数据库索引优化注意事项</guid>
                <pubDate>2014-02-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>phonegap 3.3 环境搭建</title>
                <description>&lt;h3 id='phonegap'&gt;&lt;a href='http://phonegap.com/'&gt;phonegap官网地址&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id='phonegap'&gt;&lt;a href='http://phonegap.com/install/'&gt;phonegap官方安装教程&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id='id73'&gt;一.依赖环境&lt;/h3&gt;

&lt;p&gt;phonegap 3.3需要&lt;code&gt;nodejs&lt;/code&gt;的环境&lt;/p&gt;

&lt;p&gt;&lt;a href='http://nodejs.org/download/'&gt;nodejs下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nodejs&lt;/code&gt;傻瓜式安装就行&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id='phonegap'&gt;二.安装phonegap&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;nodejs&lt;/code&gt;安装完成之后&lt;code&gt;phonegap&lt;/code&gt;的安装就很简单了,运行下面的命令即可:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo npm install -g phonegap&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一步很简单。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id='app'&gt;三.创建app&lt;/h3&gt;

&lt;p&gt;创建app十分简单,运行下面的命令即可:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;phonegap create test-app &amp;quot;com.test.app&amp;quot; &amp;quot;appname&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令参数的意思分别为:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;test-app &lt;code&gt;app创建所在的目录&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;com.test.app &lt;code&gt;appid&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;appname &lt;code&gt;app名称&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h3 id='ios'&gt;四.输出到IOS&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd test-app
phonegap run ios&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出完成之后，会在&lt;code&gt;test-app/platforms/ios&lt;/code&gt;目录下生成XCode工程文件&lt;/p&gt;

&lt;p&gt;ios输出就算完成了&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id='android'&gt;五.输出到android&lt;/h3&gt;

&lt;p&gt;ios的输出十分简单&lt;/p&gt;

&lt;p&gt;android的输出稍微复杂一点，主要是需要android的sdk以及几个环境变量的配置&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.配置ant&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://ant.apache.org/'&gt;ant下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载完成并且解压之后 将&lt;code&gt;ant&lt;/code&gt;的&lt;code&gt;bin&lt;/code&gt;目录配置到环境变量&lt;/p&gt;

&lt;p&gt;环境变量怎么配置就不讲了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.配置android环境&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://developer.android.com/sdk/index.html'&gt;android sdk下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载完成并解压之后回获得两个目录，分别是&lt;code&gt;eclipse&lt;/code&gt;和&lt;code&gt;sdk&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;默认打开&lt;code&gt;eclipse&lt;/code&gt; &lt;code&gt;android&lt;/code&gt;环境就已经搭建完成&lt;/p&gt;

&lt;p&gt;但是光是这样phonegap还不能输出android&lt;/p&gt;

&lt;p&gt;将&lt;code&gt;sdk/tools&lt;/code&gt;,&lt;code&gt;sdk/platform-tools&lt;/code&gt;两个目录都加入环境变量 即可&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.输出&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd test-app
phonegap run android&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出完成之后，会在&lt;code&gt;test-app/platforms/android&lt;/code&gt;目录下生成android的相关工程文件&lt;/p&gt;</description>
                <link>http://zmliu.github.io/2014/01/23/phonegap%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA</link>
                <guid>http://zmliu.github.io/2014/01/23/phonegap环境搭建</guid>
                <pubDate>2014-01-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>mac环境变量配置</title>
                <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.启动终端Terminal&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.进入当前用户的home目录&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入cd ~&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.创建.bash_profile&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入touch .bash_profile&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;4.编辑.bash_profile文件&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi ~/.bash_profile
export PATH=/usr/local/mysql/bin:$PATH
:wq
source ~/.bash_profile&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;5.查看是否生效&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $PATH&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://zmliu.github.io/2014/01/22/mac%E4%B8%8B%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F</link>
                <guid>http://zmliu.github.io/2014/01/22/mac下设置环境变量</guid>
                <pubDate>2014-01-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>StarlingSwf 自定义组件</title>
                <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;有些同学使用过程用遇到了问题。我开了一个QQ群。有问题的同学可以进来问一下群号是168436154&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://zmliu.github.io/2013/11/09/StarlingSwfTool/'&gt;StarlingSwf&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id='id71'&gt;自定义组件是为了能够轻松的添加一些有特定功能的组件&lt;/h4&gt;

&lt;h4 id='ui'&gt;也可以轻松的把现有的ui框架集成到程序中&lt;/h4&gt;

&lt;h4 id='__flash_pro'&gt;比方说&lt;code&gt;Feathers&lt;/code&gt;的组件 通过&lt;code&gt;StarlingSwf&lt;/code&gt;的自定义组件 就可以在Flash pro中编辑并布局啦&lt;/h4&gt;

&lt;h1 id='id72'&gt;教程&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1、组件的链接命名规则&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以&lt;code&gt;comp&lt;/code&gt;开头就会被识别为组件。但是单单以&lt;code&gt;comp&lt;/code&gt;开头是不科学的。比方说的要定制一个&lt;code&gt;feathers&lt;/code&gt;的&lt;code&gt;button&lt;/code&gt;那么组件的链接名称可以命名为&lt;code&gt;comp_feathers_btn&lt;/code&gt;这个看个人喜好。但是必须以&lt;code&gt;comp&lt;/code&gt;开头&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;2、按照一定的规则编辑Flash pro中的元件&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个部分的规则，由开发组件的 开发者定义。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;3、编写组件的类文件&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;StarlingSwf&lt;/code&gt;的自定义组件都需要实现&lt;code&gt;ISwfComponent&lt;/code&gt;这个接口。然后实现接口中的&lt;code&gt;initialization&lt;/code&gt;方法即可&lt;/p&gt;

&lt;p&gt;&lt;code&gt;initialization&lt;/code&gt;方法的参数&lt;code&gt;componetContent&lt;/code&gt;是一个临时存放 组件需要的显示对象的容器。不会被其他对象引用。封装组件时 可以按自己的需求对他进行释放操作&lt;/p&gt;

&lt;p&gt;但是很多时候，可能需要在fla中制作一个公用组件。然后各处引用 这样就满足不了一些需求了 所以：这里引入了组件可编辑属性了机制&lt;/p&gt;

&lt;p&gt;只要实现&lt;code&gt;editableProperties&lt;/code&gt;方法 工具就能让你编辑组件属性&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;4、在组件配置列表中加入配置组件&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;组件的类文件编辑好了。接下来在&lt;code&gt;ComponentConfig&lt;/code&gt;这个类中配置一下就可以动态的创建组件了&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;5、例子&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里我使用&lt;code&gt;feathers&lt;/code&gt;的&lt;code&gt;button&lt;/code&gt;简单的编写一个组件&lt;/p&gt;

&lt;p&gt;先了解清楚&lt;code&gt;button&lt;/code&gt;展示的构成部分,&lt;code&gt;feathers&lt;/code&gt;的&lt;code&gt;button&lt;/code&gt;我这里简单的设置他的三个状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.普通状态
2.鼠标按下状态
3.鼠标抬起的状态&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;准备资源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;我直接使用了`feathers`官方的资源,并且在fla中编辑好，如图:&lt;/code&gt;&lt;/pre&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool_components/image1.png' /&gt;
&lt;p&gt;编辑fla中的组件&lt;/p&gt;

&lt;p&gt;首先新建一个元件链接名字命名为如图：&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool_components/image2.png' /&gt;
&lt;p&gt;然后编辑相应的显示对象：&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool_components/image3.png' /&gt;&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool_components/image4.png' /&gt;&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool_components/image5.png' /&gt;
&lt;p&gt;组件类文件编写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package lzm.starling.swf.components.feathers
{
	import flash.text.TextFormat;
	
	import feathers.controls.Button;
	
	import lzm.starling.swf.components.ISwfComponent;
	import lzm.starling.swf.display.SwfSprite;
	
	import starling.display.DisplayObject;
	import starling.text.TextField;

	public class FeathersButton extends Button implements ISwfComponent
	{
		
		public function initialization(componetContent:SwfSprite):void{
			var _upSkin:DisplayObject = componetContent.getChildByName(&amp;quot;_upSkin&amp;quot;);
			var _selectUpSkin:DisplayObject = componetContent.getChildByName(&amp;quot;_selectUpSkin&amp;quot;);
			var _downSkin:DisplayObject = componetContent.getChildByName(&amp;quot;_downSkin&amp;quot;);
			var _disabledSkin:DisplayObject = componetContent.getChildByName(&amp;quot;_disabledSkin&amp;quot;);
			var _selectDisabledSkin:DisplayObject = componetContent.getChildByName(&amp;quot;_selectDisabledSkin&amp;quot;);
			
			var _labelTextField:TextField = componetContent.getTextField(&amp;quot;_labelTextField&amp;quot;);
			
			this.defaultSkin = _upSkin;
			if(_selectUpSkin) this.defaultSelectedSkin = _selectUpSkin;
			if(_downSkin) this.downSkin = _downSkin;
			if(_disabledSkin) this.disabledSkin = _disabledSkin;
			if(_selectDisabledSkin) this.selectedDisabledSkin = _selectDisabledSkin;
			
			if(_labelTextField){
				var textFormat:TextFormat = new TextFormat();
				textFormat.font = _labelTextField.fontName;
				textFormat.size = _labelTextField.fontSize;
				textFormat.color = _labelTextField.color;
				textFormat.bold = _labelTextField.bold;
				textFormat.italic = _labelTextField.italic;
				
				this.defaultLabelProperties.textFormat = textFormat;
				this.label = _labelTextField.text;
			}
			
			componetContent.removeFromParent(true);
		}
		
		public function get editableProperties():Object{
			return {
				label:label,
				isEnabled:isEnabled
			};
		}
		
		public function set editableProperties(properties:Object):void{
			for(var key:String in properties){
				this[key] = properties[key];
			}
		}
		
	}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置组件&lt;/p&gt;

&lt;p&gt;打开&lt;code&gt;lzm.starling.swf.components.ComponentConfig&lt;/code&gt;找到&lt;code&gt;componentClass&lt;/code&gt;,添加对应的组件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static var componentClass:Object = {
	&amp;quot;comp_feathers_btn&amp;quot;:FeathersButton
	&amp;quot;其他&amp;quot;:其他
};&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;以上操作完成 组件就添加完毕啦。&lt;/p&gt;

&lt;p&gt;以代码方式启动工具 就能在工具中预览了。&lt;/p&gt;

&lt;p&gt;如果不是以代码方式启动工具。那么工具中 新添加的自定义组件会以&lt;code&gt;sprite&lt;/code&gt;的方式呈现，不会有组件的特性。就需要到自己的工程里面 创建swf然后预览了&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;例子中的fla在&lt;a href='https://github.com/zmLiu/StarlingSWF/tree/0.0.8/StarlingSWF-Test/testFla'&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后来一张预览截图&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool_components/image6.png' /&gt;</description>
                <link>http://zmliu.github.io/2014/01/07/StarlingSwf-Components</link>
                <guid>http://zmliu.github.io/2014/01/07/StarlingSwf-Components</guid>
                <pubDate>2014-01-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>StarlingSwf 下载 与 更新</title>
                <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;有些同学使用过程用遇到了问题。我开了一个QQ群。有问题的同学可以进来问一下群号是168436154&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id='atf'&gt;ATF工具说明&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Atf&lt;/code&gt;工具之前是独立的。现在已经合并到StarlingSwf中。 如需要使用 直接下载StarlingSwf的mac或者windows版本即可。&lt;code&gt;Atf&lt;/code&gt;工具的&lt;code&gt;入口&lt;/code&gt;就在主界面上。很大一个按钮。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href='https://github.com/zmLiu/StarlingFeathers'&gt;依赖库最新源码&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id='v101'&gt;V1.0.1&lt;/h2&gt;

&lt;p&gt;修复一处内存泄漏&lt;/p&gt;

&lt;p&gt;开通贡献页面&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/Pd6Obg'&gt;Mac版下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/RES4x1'&gt;Windows版下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/LnCMaU'&gt;依赖库&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/M5EKz0'&gt;Demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;更新时间2014-03-19&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id='v100'&gt;V1.0.0&lt;/h2&gt;

&lt;p&gt;导出纹理集时，自动裁剪图片透明区域&lt;/p&gt;

&lt;p&gt;支持粒子系统&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/PapVzg'&gt;Mac版下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/KyyiqG'&gt;Windows版下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/RYmSH0'&gt;依赖库&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/Ri7WRV'&gt;Demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;更新时间2014-03-19&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;V0.0.9&lt;/p&gt;

&lt;p&gt;批量倒入&lt;/p&gt;

&lt;p&gt;批量导出&lt;/p&gt;

&lt;p&gt;记录最后一次倒入的文件夹&lt;/p&gt;

&lt;p&gt;记录最后一次倒出的文件夹&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/O3oTqz'&gt;Mac版下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/P5KRcb'&gt;Windows版下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/LKGNQw'&gt;依赖库&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;更新时间2014-03-19&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;V0.0.8&lt;/p&gt;

&lt;p&gt;修改由于分配显示对象导致的动画嵌套播放顺序错乱的bug&lt;/p&gt;

&lt;p&gt;组件现在可以通过&lt;code&gt;lzm.starling.swf.components.ComponentConfig&lt;/code&gt;来配置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;更新到该版本.bytes文件需要重新使用工具导出一次&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/NGhZPg'&gt;Mac版下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/M8qnJ2'&gt;Windows版下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/RxDO4M'&gt;依赖库&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;更新时间2014-02-26&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;V0.0.7&lt;/p&gt;

&lt;p&gt;增加自定义组件机制&lt;/p&gt;

&lt;p&gt;封装部分Feathres的组件&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/TUabD8'&gt;Mac版下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/R3QiWY'&gt;Windows版下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/QkQkOb'&gt;Demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/PFeYz3'&gt;Demo中Fla的兼容版本&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/RnR9zq'&gt;依赖库&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;更新时间2013-01-09&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;V0.0.6(依赖库也需要更新)&lt;/p&gt;

&lt;p&gt;添加一个组建(SwfSprite取子对象的时候更加方便了)&lt;/p&gt;

&lt;p&gt;整合ATF批量导出工具&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/L1sdOH'&gt;Mac版下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/R6nIbu'&gt;Windows版下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/ImSywX'&gt;Demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/NKURPS'&gt;Demo中Fla的兼容版本&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;更新时间2013-12-18&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;V0.0.5&lt;/p&gt;

&lt;p&gt;自动检测新版本&lt;/p&gt;

&lt;p&gt;添加一个组建(ShapeImage)&lt;/p&gt;

&lt;p&gt;动画效率优化(提升不是很大)&lt;/p&gt;

&lt;p&gt;bug修改&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/SgKcNp'&gt;Mac版下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/L1Z5k9'&gt;Windows版下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/LeNC4X'&gt;Demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://url.cn/Ml9n7u'&gt;Demo中Fla的兼容版本&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;更新时间2013-12-17&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;V0.0.4&lt;/p&gt;

&lt;p&gt;修复scale9imag的scaleGrid取值的bug&lt;/p&gt;

&lt;p&gt;更新时间2013-12-09&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;V0.0.3&lt;/p&gt;

&lt;p&gt;修复文字对齐方式的bug.&lt;/p&gt;

&lt;p&gt;修复读取原件没有读取边框的bug.&lt;/p&gt;

&lt;p&gt;更新时间2013-11-13&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;V0.0.2&lt;/p&gt;

&lt;p&gt;支持自动合并纹理，并且可以自动单独导出大图&lt;/p&gt;

&lt;p&gt;更新时间2013-11-13&lt;/p&gt;</description>
                <link>http://zmliu.github.io/2013/12/17/StarlingSwfToolUpdate</link>
                <guid>http://zmliu.github.io/2013/12/17/StarlingSwfToolUpdate</guid>
                <pubDate>2013-12-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>StarlingSwf UI管理扩展</title>
                <description>&lt;h2 id='id65'&gt;下载&lt;/h2&gt;

&lt;p&gt;&lt;a href='https://github.com/jiessie-GIT/jis'&gt;源码以及示例下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://jiessie-git.github.io/jis_blog/'&gt;api地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://zmliu.github.io/2013/11/09/StarlingSwfTool/'&gt;StarlingSwf&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id='id66'&gt;该扩展的优势&lt;/h2&gt;

&lt;p&gt;该扩展主要针对手机开发，当然做页游也可以。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;没有使用过传统swf做UI的可以忽略此处&lt;/code&gt;，大家刚开始使用starling的时候通常都是swf+starling进行开发，而这个时候你的UI好多功能在手机上的效果那就不是一个惨字能表示的~比如拖拽，随便拖一下就把你的帧数降到20帧以下，更不要提现在手机上流行的滚动拖拽页面了，而本工具以及StarlingSwf就针对这部分人群，相信已经玩的很转的swf做UI的你们接触应该不会很难，StarlingSwf将你熟悉的Swf以Starling的方式展现给你，而该扩展将在你熟悉的基础上给你更简单方便的UI制作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;内存方面：&lt;/code&gt;大家都知道手机的内存有限，很多时候UI不会进行缓存，然而UI使用完毕之后的销毁将会是一个头疼的问题，使用传统的swf做UI的话，swf文件有时候哪怕你存在了一个引用都不会进行销毁，而其他的场景有可能就差这么点内存就蹦了。该扩展销毁资源的时候采用强制销毁模式，销毁的是你加载的资源，哪怕你正在使用也会销毁。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id='id67'&gt;使用之前的准备步骤：&lt;/h2&gt;

&lt;p&gt;首先呢，你需要了解StarlingSwf工具的基本使用。&lt;/p&gt;

&lt;p&gt;你需要使用StarlingSwf将你的swf来进行导出，导出的3个文件建议放到一个文件夹下，&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_jiessie/image0.png' /&gt;
&lt;p&gt;该UI扩展需要你布置swf的时候稍微下点功夫，如下示例&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_jiessie/image1.png' /&gt;&lt;hr /&gt;
&lt;h2 id='id68'&gt;在程序中使用：&lt;/h2&gt;

&lt;p&gt;在使用该扩展之前你需要初始化两个地方：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Swf.init(stage); //只有初始化该信息才能使用SwfMovieClip
JISConfig.windowStage = starling.display.DisplayObjectContainer; //只有设置该值才能使用JISWindow&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id='window'&gt;建立第一个Window&lt;/h2&gt;

&lt;p&gt;比如我们第一个Window命名为JISMainUIWindow&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//我们需要在构造函数中调用父类构造
super(“spr_TestWindow”,”test”);
//然后设置窗口资源
setAssetSource(File.applicationDirectory.resolvePath(&amp;quot;assets/ui/test/&amp;quot;));
//调用show();
show();
这样window就开始加载并且在加载完毕之后显示了。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;其中super的两个参数第一个为swf的导出链接名字&lt;/code&gt;&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_jiessie/image2.png' /&gt;
&lt;p&gt;第二个参数为文件的名字&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_jiessie/image3.png' /&gt;
&lt;p&gt;&lt;code&gt;setAssetSource&lt;/code&gt;可以设置一个File，如果是文件夹的话，会扫描文件夹下所有文件，如果你的是web资源的话，你可以设置一个Url数组：&lt;code&gt;[“../assets/ui/test/test.bytes”, “../assets/ui/test/test.png”, “../assets/ui/test/test.xml”]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如此，我们的第一个Window就创建好并能够显示了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id='window'&gt;管理Window中的组件：&lt;/h2&gt;

&lt;p&gt;我们的window中有个组件名字为_BtnList,如图：&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_jiessie/image4.png' /&gt;
&lt;p&gt;这个组件内部为4个按钮，命名分别为：_Btn_1、_Btn_2、_Btn_3、_Btn_4&lt;/p&gt;

&lt;p&gt;按钮是一个mc，导出的也是mc&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_jiessie/image5.png' /&gt;
&lt;p&gt;我们可以使用JISCuttingButtonGroup进行管理我们的btn列表，如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public var _BtnList:JISCuttingButtonGroup;
public function JISMainUIWindow()
{
	_BtnList = new JISCuttingButtonGroup(&amp;quot;_Btn_&amp;quot;,JISButton);
	super(&amp;quot;spr_TestWindow&amp;quot;, &amp;quot;test&amp;quot;);
setAssetSource(File.applicationDirectory.resolvePath(&amp;quot;assets/ui/test/&amp;quot;));
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;_BtnList&lt;/code&gt;必须为public类型，并且必须在setAssetSource之前实例化&lt;/p&gt;

&lt;p&gt;JISCuttingButtonGroup的第一个参数为需要管理的组件的共有特征命名，第二个参数是设置组件有哪个类进行管理，初始化的时候会new该类，并将按钮显示对象通过setCurrDisplay传入进去。&lt;/p&gt;

&lt;p&gt;进行管理之前我们的btn是不断闪烁的，管理之后我们的btn会有一个为选中状态，其他为正常状态&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id='window'&gt;管理window中的对象：&lt;/h2&gt;

&lt;p&gt;我们的示例文件中有一个空的影片剪辑和一个按钮，如图：&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_jiessie/image6.png' /&gt;&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_jiessie/image7.png' /&gt;
&lt;p&gt;由于我们的_ScrollTable是Sprite类型，为系统组件，所以不用提前new出来，我们的_AddTableCellBtn是自定义组件，所以需要事先new出来，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public var _ScrollTable:Sprite;
public var _AddTableCellBtn:JISButton;
public function JISMainUIWindow()
{
	_AddTableCellBtn = new JISButton();
	super(&amp;quot;spr_TestWindow&amp;quot;, &amp;quot;test&amp;quot;);
	setAssetSource(File.applicationDirectory.resolvePath(&amp;quot;assets/ui/test/&amp;quot;));
}
现在我们创建一个JISScrollTable添加到_ScrollTable中，

/** init会在资源加载完毕并且建立引用之后调用 */
protected override function init():void
{
	tableScroll = new JISScrollTable();
	_ScrollTable.addChild(tableScroll);
	tableScroll.getTable().setCellInstanceClass(JISTableTestCell);//设置Table创建个显示对象类型
	tableScroll.getTable().setPreferredWidth(100);//设置Table最大宽度
	tableScroll.getTable().setPreferredCellWidth(48);//设置每个格子宽度，默认为JISTableTestCell#getDisplay()的宽度
	tableScroll.getTable().setPreferredCellHeight(35);//设置每个格子高度，默认为JISTableTestCell#getDisplay()的高度
	//tableScroll.getTable().setIsRow(true);//设置表格布局方式，true横向布局,false竖向布局
	var cellList:Array = [];
	for(;btnIndex&amp;lt;100;btnIndex++) cellList.push(btnIndex);
	tableScroll.width = 100;//设置滚动区域的宽度
	tableScroll.height = 200;//设置滚动区域的高度
	tableScroll.getTable().setCellDatas(cellList,this.getSourceSwf());//创建格子内容
	//按钮点击事件					
	_AddTableCellBtn.addEventListener(JISButton.BOTTON_CLICK,onBtnClickHandler);
}
private function onBtnClickHandler(e:Event):void
{
	tableScroll.getTable().addCellData(btnIndex++,this.getSourceSwf());//添加新的格子
}
JISTableTestCell的代码：
package
{
	import jis.ui.JISUISprite;
	import jis.ui.component.JISITableCell;
	
	import lzm.starling.swf.Swf;
	
	import starling.display.DisplayObject;
	import starling.text.TextField;
	
	
	/**
	 * 
	 * @author jiessie 2013-11-27
	 */
	public class JISTableTestCell extends JISUISprite implements JISITableCell
	{
		public var _Text:TextField;
		public function JISTableTestCell(swf:Swf)
		{
			super(&amp;quot;&amp;quot;,&amp;quot;&amp;quot;);
			setCurrDisplay(swf.createSprite(&amp;quot;spr_TableCell&amp;quot;));
		}
		
		public function setValue(value:*):void
		{
			_Text.text = value;
		}
		
		public override function getDisplay():DisplayObject
		{
			return this;
		}
		
		public function selected(select:Boolean=false):void
		{
		}
		
		public function getValue():*
		{
			return _Text.text;
		}
		
		public override function dispose():void
		{
		}
	}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到&lt;code&gt;JISTableTestCell&lt;/code&gt;中的构造函数需要一个Swf对象，而创建格子的参数中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tableScroll.getTable().setCellDatas(cellList,this.getSourceSwf());//创建格子内容
tableScroll.getTable().addCellData(btnIndex++,this.getSourceSwf());//添加新的格子&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;都会传入一个Swf对象，这就可以看出&lt;code&gt;setCellDatas&lt;/code&gt;和&lt;code&gt;addCellData&lt;/code&gt;会在创建&lt;code&gt;JISTableTestCell&lt;/code&gt;的时候将swf传入&lt;/p&gt;

&lt;p&gt;&lt;code&gt;JISTableTestCell&lt;/code&gt;继承&lt;code&gt;JISUISprite&lt;/code&gt;说明&lt;code&gt;JISTableTestCell&lt;/code&gt;可以使用该扩展进行管理UI，其中的&lt;code&gt;setCurrDisplay(swf.createSprite(&amp;quot;spr_TableCell&amp;quot;));&lt;/code&gt;为从资源库中创建一个sprite赋值给当前类，然后当前类会进行管理其中的内容，我们可以看下资源：&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_jiessie/image8.png' /&gt;
&lt;p&gt;而我们的JISTableTestCell中也有个_Text属性。&lt;/p&gt;

&lt;p&gt;JISTableTestCell中的setValue()可以输出通过setCellDatas和addCellData中设置的值。如此一个支持触控滑动的滚动界面就完毕了，跟手机上绚丽的滑动效果一样哦。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id='id69'&gt;自定义组件管理：&lt;/h2&gt;

&lt;p&gt;如我们的演示资源中有个进度条面板，其中有_ProgressText、_RowProgress、_AddBtn、_DecBtn&lt;/p&gt;

&lt;p&gt;其中_RowProgress是一个mc，其中存在一个背景和一个前景，前景我们命名为_Center，因为扩展提供的JISUIProgressManager需要进度条的名字为_Center，如图：&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_jiessie/image9.png' /&gt;
&lt;p&gt;该组件在window中的名字为_ProgressTest，如图：&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_jiessie/image10.png' /&gt;
&lt;p&gt;首先我们先建立对应_ProgressTest的类，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package
{
	import jis.ui.JISUIManager;
	import jis.ui.component.JISButton;
	import jis.ui.component.JISUIProgressManager;
	
	import starling.events.Event;
	import starling.text.TextField;
	
	
	/**
	 * 
	 * @author jiessie 2013-11-27
	 */
	public class JISProgressTestUIManager extends JISUIManager
	{
		public var _RowProgress:JISUIProgressManager;
		public var _AddBtn:JISButton;
		public var _DecBtn:JISButton;
		public var _ProgressText:TextField;
		
		private var currProgress:int = 0;
		
		public function JISProgressTestUIManager()
		{
			_RowProgress = new JISUIProgressManager();
			_AddBtn = new JISButton();
			_DecBtn = new JISButton();
			super();
		}
		
		protected override function init():void
		{
			_AddBtn.addEventListener(JISButton.BOTTON_CLICK,onClickAddHandler);
			_DecBtn.addEventListener(JISButton.BOTTON_CLICK,onClickDecHandler);
			updateProgress();
		}
		
		private function onClickAddHandler(e:Event):void
		{
			if(currProgress &amp;lt; 100)
			{
				currProgress ++;
				updateProgress();
			}
		}
		
		private function onClickDecHandler(e:Event):void
		{
			if(currProgress &amp;gt; 0)
			{
				currProgress --;
				updateProgress();
			}
		}
		
		private function updateProgress():void
		{
			_RowProgress.setProgress(currProgress,100);
			_ProgressText.text = currProgress+&amp;quot;/100&amp;quot;;
		}
	}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以看到JISProgressTestUIManager是继承的JISUIManager，代表他只是管理UI，不会进行addChild操作&lt;/p&gt;

&lt;p&gt;JISProgressTestUIManager中的成员与mc中的成员命名一模一样，层级结构也很类似，只不过一个是代码的层级结构(对象包含属性)，一个是显示对象的层级结构(mc包含mc、TextField)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id='id70'&gt;组件一览：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;JISButton  按钮，实际上就是包装了一个SwfMovieClip，每帧代表的含义参考静态DEFULT、GLIDE、CLICK、SELECTED、ENABLE所代表的帧数

JISButtonGroup JISButton集合管理，该集合管理的按钮同一时间只能选择一个 用法：初始化传入JISButton集合或者是通过setBtnList设置集合 当设置集合或者是选中按钮的时候会抛出CLICK_BTN事件和调用selectHandler函数，也可以当成组件来使用，会自动扫描子显示对象是否为SwfMovieClip，如果是则创建JISButton进行管理

JISCuttingButtonGroup 集成JISButtonGroup的JISDisplayCutting，会将切割的管理对象交由JISButtonGroup进行管理

JISDisplayCutting 切割显示对象管理，管理一个sprite中命名规则如：g1、g2、g3...这种以固定标识开头的显示对象 你可以通过初始化的时候传入标识字符和切割后进行管理的类，程序会在切割的时候自动创建对应的管理类，然后交由管理类来进行管理该显示对象 管理类必须为JISUIManager的子类 通过该类进行管理子对象的话，子对象必须实现JISIDisplayCuttingCell接口

JISIconManager 图标管理类,内部封装了JISImageSprite，使用该类的话Sprite中必须包含一个命名为_IconMovie的Sprite

JISIDisplayCuttingCell 只有实现该接口JISIDisplayCutting才能通过setSpliceMovieDatas、setSpliceMovieData、setSpliceMovieDatasForIndex、setSpliceForIndex、setSpliceForLast 进行动态添加内容

JISIDisplayCuttingCellData 数据实现该接口的话可以动态的将数据通过JISDisplayCutting进行赋值

JISImageSprite 图片容器，可以加载一个图片进行显示

JISISpriteManager 管理UI接口 通常情况下从swf中获取的显示对象是美术人员制作好的一整个UI，我们需要通过引用的方式来管理这些UI中零散的显示组件， 实现该接口的对象会由JISManagerSpriteUtil调用setCurrDisplay的方式设置一个显示对象， 如果你需要的只是简单的引用请不要addChild。 设置引用采用的为递归的方式，只要成员是实现该接口的类，就可以无限递归 规则： 1.子类属性名必须是public类型 2.子类属性名必须与显示对象name相同 3.如果不是系统组件的话需要在构造函数中new出来 
示例: 
public var _Text:TextField; 
public var _Btn:JISButton; 
public function test() { 
	_Btn = new JISButton(); 
} 
对应swf的display display.getChildByName(&amp;quot;_Text&amp;quot;)为TextField display.getChildByName(&amp;quot;_Btn&amp;quot;)为SwfMovieClip

JISITableCell  添加表格中显示内容的话必须实现该接口

JISProgress 进度条，该进度条不为UI组件，如果想在UI中使用的话请使用JISUIProgressManager

JISScrollTable  能够滚动的Table,操作table内容的话请调用getTable()获取JISTable实例

JISSimpleLoaderSprite 加载模版，子类可以直接继承该类实现加载资源并显示的功能 使用方式：通过本类setAssetSource的方式设置加载内容，加载完毕之后会调用子类loadComplete方法

JISTable 表格

JISUIEffect 管理UI中的特效，目前只支持特效从xx帧播放到xx帧，每次调用start都会从指定起始帧开始播放

JISUIManager ui管理，该类管理的UI不会进行addChild操作，只会当作引用来进行管理

JISUIMovieClipManager 该类只是将管理的display转换为SwfMovieClip，方便使用

JISUIMovieClipSprite 该类只是将管理的display转换为SwfMovieClip，方便使用

JISUIProgressManager 管理UI中的进度条组件，UI需要具备命名为_Center的Display，当设置进度的时候会改变_Center的width或者height属性，建议_Center为Scale9Image 可选组建_Text类型为TextField，存在该组件的话，会在设置进度的时候赋值“当前进度/最大进度”

JISUISprite UI基础类,该类负责将swf中内容进行同步以及显示

JISUIWindow  窗口，可选按钮_Close，必须符合JISButton按钮标准，如果该按钮存在，那么点击该按钮会关闭窗口

JISUIWindowManager UI中管理窗口，比如设计UI的时候窗口中存在2级窗口，就可以使用该窗口进行管理，初始化的时候会关闭2级窗口 可选按钮_Close，必须符合JISButton按钮标准，如果该按钮存在，那么点击该按钮会关闭窗口&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常情况下我们都是JISWindow或者是JISUISprite下包含一堆的JISUIManager以及子类，然后JISUIManager中再包含一堆的JISUIManager以及子类。&lt;/p&gt;

&lt;p&gt;这么一种组件套组件下来就很简单的用程序管理一套复杂的UI了&lt;/p&gt;

&lt;p&gt;遇到问题或者更多意见欢迎加QQ群：168436154讨论&lt;/p&gt;</description>
                <link>http://zmliu.github.io/2013/12/03/StarlingSwf-jiessie</link>
                <guid>http://zmliu.github.io/2013/12/03/StarlingSwf-jiessie</guid>
                <pubDate>2013-12-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>The last packet successfully received from the server was XXX seconds ago</title>
                <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;导致这个错误的原因是mysql &lt;code&gt;wait_timeout&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;解决方法:&lt;/em&gt;&lt;/strong&gt; 设置&lt;code&gt;wait_timeout&lt;/code&gt;大于 &lt;code&gt;检测连接是否有效的 线程运行时间&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;比方说&lt;code&gt;wait_timeout=10秒&lt;/code&gt; 那么&lt;code&gt;检测连接是否有效的 线程运行时间&lt;/code&gt;就需要小于10秒&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;</description>
                <link>http://zmliu.github.io/2013/11/13/mysql-wait_timeout</link>
                <guid>http://zmliu.github.io/2013/11/13/mysql-wait_timeout</guid>
                <pubDate>2013-11-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>MySql 慢查询日志</title>
                <description>&lt;p&gt;打开my.cnf&lt;/p&gt;

&lt;p&gt;找到&lt;code&gt;[mysqld]&lt;/code&gt;在其下面添加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//查询时间大于两秒的都记录
long_query_time = 2
//日志文件地址(必须保证启动mysql的账户对目录有写权限)
log-slow-queries = /tmp/slow-query.log
//记录没有使用索引的sql语句
log-queries-not-using-indexes
//一些管理指令,也会被记录
log-slow-admin-statements&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用&lt;code&gt;mysqldumpslow&lt;/code&gt;(/mysql/bin目录下)来查看日志文件,也可以直接打开日志文件查看&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-s, 是表示按照何种方式排序，c、t、l、r分别是按照记录次数、时间、查询时间、返回的记录数来排序，ac、at、al、ar，表示相应的倒叙&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;-t, 是top n的意思，即为返回前面多少条的数据；&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;-g, 后边可以写一个正则匹配模式，大小写不敏感的；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;比如&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/path/mysqldumpslow -s r -t 10 /database/mysql/slow-log
得到返回记录集最多的10个查询。

/path/mysqldumpslow -s t -t 10 -g “left join” /database/mysql/slow-log
得到按照时间排序的前10条里面含有左连接的查询语句。&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://zmliu.github.io/2013/11/11/mysql-slow-query-log</link>
                <guid>http://zmliu.github.io/2013/11/11/mysql-slow-query-log</guid>
                <pubDate>2013-11-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>详解MySQL中EXPLAIN解释命令</title>
                <description>&lt;p&gt;explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。&lt;/p&gt;

&lt;p&gt;使用方法，在select语句前加上explain就可以了： explain select test_field from tb_test where id=1&lt;/p&gt;

&lt;p&gt;EXPLAIN列的解释：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;table&lt;/code&gt;：显示这一行的数据是关于哪张表的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;type&lt;/code&gt;：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL&lt;/p&gt;

&lt;p&gt;&lt;code&gt;possible_keys&lt;/code&gt;：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句&lt;/p&gt;

&lt;p&gt;&lt;code&gt;key&lt;/code&gt;： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引&lt;/p&gt;

&lt;p&gt;&lt;code&gt;key_len&lt;/code&gt;：使用的索引的长度。在不损失精确性的情况下，长度越短越好&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ref&lt;/code&gt;：显示索引的哪一列被使用了，如果可能的话，是一个常数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rows&lt;/code&gt;：MYSQL认为必须检查的用来返回请求数据的行数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Extra&lt;/code&gt;：关于MYSQL如何解析查询的额外信息&lt;/p&gt;</description>
                <link>http://zmliu.github.io/2013/11/11/mysql-explain</link>
                <guid>http://zmliu.github.io/2013/11/11/mysql-explain</guid>
                <pubDate>2013-11-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>StarlingSwf</title>
                <description>&lt;h4 id='swfstarlingstarlingmovieclip'&gt;Swf一键导出到Starling中的工具，在Starling使用原生的MovieClip&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;有些同学使用过程用遇到了问题。我开了一个QQ群。有问题的同学可以进来问一下群号是168436154&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id='id58'&gt;目录&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.&lt;/em&gt;&lt;/strong&gt; &lt;a href='#whatThis'&gt;StarlingSwf是什么&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.&lt;/em&gt;&lt;/strong&gt; &lt;a href='#featuresFunctions'&gt;功能与特色&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.&lt;/em&gt;&lt;/strong&gt; &lt;a href='http://zmliu.github.io/2013/12/17/StarlingSwfToolUpdate/' target='_blank' id='downInstall'&gt;下载与安装&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;4.&lt;/em&gt;&lt;/strong&gt; &lt;a href='#Tutorials1'&gt;教程一：资源命名规则&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;5.&lt;/em&gt;&lt;/strong&gt; &lt;a href='#Tutorials2'&gt;教程二：针对设计师&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;6.&lt;/em&gt;&lt;/strong&gt; &lt;a href='#Tutorials3'&gt;教程三：针对程序&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;7.&lt;/em&gt;&lt;/strong&gt; &lt;a href='#Tutorials4'&gt;教程四：MovieClip自动停止播放&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;8.&lt;/em&gt;&lt;/strong&gt; &lt;a href='#Tutorials5'&gt;教程五：获取界面上的元素&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;9.&lt;/em&gt;&lt;/strong&gt; &lt;a href='#Tutorials6'&gt;教程六：ATF批量导出工具如何使用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;10.&lt;/em&gt;&lt;/strong&gt; &lt;a href='http://zmliu.github.io/2014/01/07/StarlingSwf-Components/' target='_blank'&gt;自定义组件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;11.&lt;/em&gt;&lt;/strong&gt; &lt;a href='http://zmliu.github.io/2014/03/27/StarlingSwf-Particle/' target='_blank'&gt;粒子集成教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;12.&lt;/em&gt;&lt;/strong&gt; &lt;a href='#SuccessStories'&gt;成功案例&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;13.&lt;/em&gt;&lt;/strong&gt; &lt;a href='http://zmliu.github.io/2014/04/12/StarlingSwf-Donate/' target='_blank'&gt;捐助StarlingSwf&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;&lt;h2 id='whatThis'&gt;StarlingSwf是什么&lt;/h2&gt;
&lt;p&gt;StarlingSwf是一套开源的 Swf数据导出到Starling框架中使用的工具.&lt;/p&gt;

&lt;p&gt;他可以让开发导出Swf数据到Starling中渲染&lt;/p&gt;
&lt;hr /&gt;&lt;h2 id='featuresFunctions'&gt;功能与特色&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.&lt;/em&gt;&lt;/strong&gt; 导出Swf数据到Starling中&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.&lt;/em&gt;&lt;/strong&gt; 在Starling中还原Swf中原件的层级关系、动画、原件属性&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.&lt;/em&gt;&lt;/strong&gt; 支持原件嵌套，动画嵌套&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;4.&lt;/em&gt;&lt;/strong&gt; MovieClip基本还原了传统Flash的MovieClip&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;5.&lt;/em&gt;&lt;/strong&gt; 使用了类似骨骼动画的思想，内存占用低、运行效率高&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;6.&lt;/em&gt;&lt;/strong&gt; 自动合并纹理，并且可以自动单独导出大图&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id='id59'&gt;&lt;a href='http://zmliu.github.io/2013/12/17/StarlingSwfToolUpdate/' target='_blank' id='downInstall'&gt;下载与安装(点我)&lt;/a&gt;&lt;/h2&gt;
&lt;hr /&gt;&lt;h2 id='Tutorials1'&gt;教程一：原件命名规则&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;既然是Swf那么资源的编辑肯定还是用Flash Pro了，但是资源的命名规则大家需要注意下(&lt;code&gt;是AS链接名称噢&lt;/code&gt;)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.&lt;/em&gt;&lt;/strong&gt; img 开始会被识别为starling.display.Image.&lt;strong&gt;(&lt;code&gt;这个必须是元件。不能直接用图片&lt;/code&gt;,导出之后该原件会直接被映射为一张图片)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.&lt;/em&gt;&lt;/strong&gt; s9 开头会被识别为feathers.display.Scale9Image.&lt;strong&gt;(制作规则跟传统flash开发一样)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.&lt;/em&gt;&lt;/strong&gt; btn 开头会被识别为lzm.starling.display.Button.(&lt;strong&gt;Button中使用的任意显示对象必须是&lt;code&gt;img&lt;/code&gt; &lt;code&gt;s9&lt;/code&gt; &lt;code&gt;btn&lt;/code&gt; &lt;code&gt;mc&lt;/code&gt; &lt;code&gt;spr&lt;/code&gt;中制作的对象&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;4.&lt;/em&gt;&lt;/strong&gt; mc 开头会被识别为lzm.starling.swf.display.SwfMovieClip.(&lt;strong&gt;MoviecClip中使用的任意显示对象必须是&lt;code&gt;img&lt;/code&gt; &lt;code&gt;s9&lt;/code&gt; &lt;code&gt;btn&lt;/code&gt; &lt;code&gt;mc&lt;/code&gt; &lt;code&gt;spr&lt;/code&gt;中制作的对象&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;5.&lt;/em&gt;&lt;/strong&gt; spr 开头会被识别为starling.display.Sprite.(&lt;strong&gt;Sprite中使用的任意显示对象必须是&lt;code&gt;img&lt;/code&gt; &lt;code&gt;s9&lt;/code&gt; &lt;code&gt;btn&lt;/code&gt; &lt;code&gt;mc&lt;/code&gt; &lt;code&gt;spr&lt;/code&gt;中制作的对象&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;6.&lt;/em&gt;&lt;/strong&gt; 文本 文本比较特殊 只要在&lt;code&gt;img&lt;/code&gt; &lt;code&gt;s9&lt;/code&gt; &lt;code&gt;btn&lt;/code&gt; &lt;code&gt;mc&lt;/code&gt; &lt;code&gt;spr&lt;/code&gt; 中写就可以了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;7.&lt;/em&gt;&lt;/strong&gt; shapeImg 开头会被识别为lzm.starling.swf.display.ShapeImage,使用纹理填充的图片(纹理长宽需要为2的幂数,改变组建宽高时，会自动使用初始化的Texture填充)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;8.&lt;/em&gt;&lt;/strong&gt; comp 开头会被识别为带特殊功能的组件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;9.&lt;/em&gt;&lt;/strong&gt; particle 开头会被识别为粒子(需要制作规范。具体请看粒子集成教程)&lt;/p&gt;
&lt;hr /&gt;&lt;h2 id='Tutorials2'&gt;教程二：针对设计师&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.&lt;/em&gt;&lt;/strong&gt;作为设计师，你只需要准备好需要展示的图片，在FlashPro中将他们有序的组装起来。并且为需要导出的原件设置链接就可以了搞定一切&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.&lt;/em&gt;&lt;/strong&gt;打开库面板，你可以看到此示例的相关资源.&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool/image1.png' /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.&lt;/em&gt;&lt;/strong&gt;相关资源编辑好之后导出Swf.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;4.&lt;/em&gt;&lt;/strong&gt;打开StarlingSwf导出工具，选择刚刚导出的swf.选择上方的下拉框，预览在Swf内部的原件在Starling中是什么样子.&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool/image2.png' /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;5.&lt;/em&gt;&lt;/strong&gt;导出。点击导出按钮。导出之后会在导出目录下，以选择的Swf名字，创建一个文件，文件夹内部存放了Swf导出之后的数据&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool/image3.png' /&gt;&lt;hr /&gt;&lt;h2 id='Tutorials3'&gt;教程三：针对程序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.&lt;/em&gt;&lt;/strong&gt;建立一个Actionscript工程。(demo中是手机工程)&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool/image4.png' /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.&lt;/em&gt;&lt;/strong&gt;倒入资源&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool/image5.png' /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.&lt;/em&gt;&lt;/strong&gt;倒入依赖库&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool/image6.png' /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;4.&lt;/em&gt;&lt;/strong&gt;代码&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;关键代码&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//初始化Swf
Swf.init(Starling的根容器);

//创建一个Swf(`layout`对应生成`.bytes`文件的名字)
var swf:Swf = new Swf(assets.getByteArray(&amp;quot;layout&amp;quot;),assets);

//根据as连接名称创建 显示对象
swf.createSprite(&amp;quot;spr_1&amp;quot;);
swf.createMovieClip(&amp;quot;mc_test1&amp;quot;);
swf.createImage(&amp;quot;img_test1&amp;quot;);
swf.createButton(&amp;quot;btn_test1&amp;quot;);
swf.createS9Image(&amp;quot;s9_test1&amp;quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;demo中的主要代码&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package
{
	import flash.filesystem.File;
	
	import lzm.starling.STLConstant;
	import lzm.starling.STLMainClass;
	import lzm.starling.swf.Swf;
	import lzm.starling.swf.SwfAssetManager;
	
	import starling.display.Sprite;
	import starling.text.TextField;
	import starling.utils.formatString;
	
	public class TestMainClass extends STLMainClass
	{
		
		private var textfield:TextField;
		private var assets:SwfAssetManager;
		
		public function TestMainClass()
		{
			super();
			
			Swf.init(this);
			
			textfield = new TextField(200,100,&amp;quot;loading....&amp;quot;);
			textfield.x = (STLConstant.StageWidth - textfield.width)/2;
			textfield.y = (STLConstant.StageHeight - textfield.height)/2;
			addChild(textfield);
			
			assets = new SwfAssetManager(STLConstant.scale,STLConstant.useMipMaps);
			assets.verbose = true;
			var file:File = File.applicationDirectory;
			
			assets.enqueue(&amp;quot;test&amp;quot;,[file.resolvePath(formatString(&amp;quot;assets/{0}x/test/&amp;quot;,STLConstant.scale))],60);
			assets.loadQueue(function(ratio:Number):void{
				textfield.text = &amp;quot;loading....&amp;quot; + int(ratio*100)+&amp;quot;%&amp;quot;;
				if(ratio == 1){
					textfield.removeFromParent(true);
					
					test1();
//					test2();
				}
			});
		}
		
		private function test1():void{
			var sprite:Sprite = assets.createSprite(&amp;quot;spr_1&amp;quot;);
			addChild(sprite);
		}
		
		private function test2():void{
			var sprite:Sprite = assets.createSprite(&amp;quot;spr_particle&amp;quot;);
			addChild(sprite);
		}
	}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;5.&lt;/em&gt;&lt;/strong&gt;运行效果&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool/image7.png' /&gt;&lt;hr /&gt;&lt;h2 id='Tutorials4'&gt;教程四：MovieClip自动停止播放&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;很多时候需要让动画播放完毕之后自动停止在最后一帧，在工具中也可以很简单的实现&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.&lt;/em&gt;&lt;/strong&gt; 倒入swf&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.&lt;/em&gt;&lt;/strong&gt; 从MovieClip列表中 选中需要自动停止的MC&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.&lt;/em&gt;&lt;/strong&gt; 取消&lt;code&gt;是否循环&lt;/code&gt;&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool/image9.png' /&gt;&lt;hr /&gt;&lt;h2 id='Tutorials5'&gt;教程五：获取界面上的元素&lt;/h2&gt;
&lt;p&gt;很简单，首先给元素命名&lt;/p&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/starling_swf_tool/image8.png' /&gt;
&lt;p&gt;然后使用&lt;code&gt;getChildByName&lt;/code&gt;获取&lt;/p&gt;
&lt;hr /&gt;&lt;h2 id='Tutorials6'&gt;教程六：ATF批量导出工具如何使用&lt;/h2&gt;
&lt;h4 id='id60'&gt;&lt;a href='http://zmliu.github.io/2013/08/31/ATFTool/'&gt;移步到这里&lt;/a&gt;&lt;/h4&gt;
&lt;hr /&gt;&lt;h2 id='SuccessStories'&gt;成功案例&lt;/h2&gt;
&lt;h4 id='id61'&gt;&lt;a href='http://ng.d.cn/zhanlvechuanqi/'&gt;战略传奇&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id='id62'&gt;&lt;a href='https://itunes.apple.com/cn/app/chuan-zhang-ye-feng-kuang/id597315819?mt=8'&gt;船长也疯狂&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id='id63'&gt;&lt;a href='http://img.tonlo.com/ttbb/download.html'&gt;天天爆爆&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id='description'&gt;&lt;a href='https://itunes.apple.com/us/app/gu-ying-jian-ke/id726049617?ls=1&amp;amp;mt=8'&gt;Description&lt;/a&gt;&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;友情提示：工具的预览区域是可以拖动的噢&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;</description>
                <link>http://zmliu.github.io/2013/11/09/StarlingSwfTool</link>
                <guid>http://zmliu.github.io/2013/11/09/StarlingSwfTool</guid>
                <pubDate>2013-11-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>如何让设备不休眠</title>
                <description>&lt;pre&gt;&lt;code&gt;NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.KEEP_AWAKE&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='id57'&gt;&lt;code&gt;Android&lt;/code&gt;需要配置&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&amp;quot;android.permission.WAKE_LOCK&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.WRITE_SETTINGS&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://zmliu.github.io/2013/09/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E8%AE%BE%E5%A4%87%E4%B8%8D%E4%BC%91%E7%9C%A0</link>
                <guid>http://zmliu.github.io/2013/09/17/如何使设备不休眠</guid>
                <pubDate>2013-09-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>NativeProcess</title>
                <description>&lt;p&gt;NativeProcess 类提供命令行集成和常规启动功能。NativeProcess 类允许 AIR 应用程序在主机操作系统上执行本机进程。AIR 应用程序可以监视进程的标准输入 (stdin) 和标准输出 (stdout) 流以及进程的标准错误 (stderr) 流。&lt;/p&gt;

&lt;h4 id='adobeatf'&gt;直接上代码(这里用adobe的ATF导出工具作为例子)&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var workingDirectory:File = File.applicationDirectory;//根据需求自己改
var executable:File = File.applicationDirectory.resolvePath(&amp;quot;png2atf&amp;quot;);//根据需求自己改
var params:Vector.&amp;lt;String&amp;gt; = new Vector.&amp;lt;String&amp;gt;();
params.push(&amp;quot;-c&amp;quot;);
params.push(&amp;quot;-i&amp;quot;);
params.push(&amp;quot;test.png&amp;quot;);
params.push(&amp;quot;-o&amp;quot;);
params.push(&amp;quot;test.atf&amp;quot;);

var info:NativeProcessStartupInfo = new NativeProcessStartupInfo();
info.workingDirectory = workingDirectory;
info.arguments = params;
info.executable = executable;

var nativeProcess:NativeProcess = new NativeProcess();
nativeProcess.addEventListener(NativeProcessExitEvent.EXIT,onExit);
nativeProcess.addEventListener(ProgressEvent.STANDARD_OUTPUT_DATA,onData);
nativeProcess.addEventListener(ProgressEvent.STANDARD_ERROR_DATA,onError);
nativeProcess.start(info);

function onExit(e:NativeProcessExitEvent):void{
	trace(&amp;quot;exit&amp;quot;);
}

function onData(e:ProgressEvent):void{
	trace(nativeProcess.standardOutput.readUTFBytes(nativeProcess.standardOutput.bytesAvailable));
}

function onError(e:ProgressEvent):void{
	trace(nativeProcess.standardError.readUTFBytes(nativeProcess.standardError.bytesAvailable));
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='id54'&gt;注意事项&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;该类只能在AIR中使用 player中无法使用
应用程序配置文件需要配置
&amp;lt;application xmlns=&amp;quot;http://ns.adobe.com/air/application/3.8&amp;quot;&amp;gt;
    ...其他配置...
    &amp;lt;supportedProfiles&amp;gt;extendedDesktop&amp;lt;/supportedProfiles&amp;gt;
&amp;lt;/application&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='id55'&gt;导出注意事项&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;只能导出为
本机安装程序
或
具有运行时绑定的应用程序
否则NativeProcess将会报错
错误信息为	Error: Error #3219: The NativeProcess could not be started. &amp;#39;Not supported in current profile.&amp;#39;&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://zmliu.github.io/2013/08/31/NativeProcess</link>
                <guid>http://zmliu.github.io/2013/08/31/NativeProcess</guid>
                <pubDate>2013-08-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ATF批量导出工具</title>
                <description>&lt;p&gt;批量导出Atf的工具，使用是adobe atf 编码核心&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id='atfbug'&gt;先说一下关于atf的bug&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;当atf导出时候 启用了mips选项 会导致：
如果纹理问长方形时 上传会报错的bug
解决方法是把纹理改成正方形&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id='id51'&gt;来张截图&lt;/h4&gt;
&lt;img class='img-rounded' alt='截图' src='/assets/images/atftool_view.png' /&gt;&lt;hr /&gt;
&lt;h4 id='id52'&gt;功能说明&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;输出平台选择
压缩体积，减小文件大小
mipmap设置
合并xml
支持jpg png 转换
图像尺寸自动纠正为2幂
图像自动转换为方形,解决atf上传时 为长方形会报错的bug 仅在使用mips会触发 所以需要启用mips可以考虑勾选这个选项
目录转换（包含子目录）
输出质量设置&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id='atfstarling'&gt;关于很多同学说导出的ATF报错的问题(只针对Starling)&lt;/h4&gt;

&lt;p&gt;其实问题很简单。了解&lt;code&gt;Texture.fromAtfData&lt;/code&gt;的几个参数就行了&lt;/p&gt;

&lt;p&gt;我们这里只要注意第&lt;code&gt;3&lt;/code&gt;个参数&lt;/p&gt;

&lt;p&gt;如果没有启用&lt;code&gt;mips&lt;/code&gt;那么第&lt;code&gt;3&lt;/code&gt;个参数必须传递&lt;code&gt;false&lt;/code&gt;否则报错&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id='xml'&gt;合并xml之后如何创建纹理&lt;/h4&gt;

&lt;p&gt;如果选择&lt;code&gt;合并xml&lt;/code&gt;，那么合并atf和xml产生的新文件会以&lt;code&gt;.xatf&lt;/code&gt;结尾&lt;/p&gt;

&lt;p&gt;以下为&lt;code&gt;.xatf&lt;/code&gt;的解析代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var urlLoader:URLLoader = new URLLoader();
urlLoader.dataFormat = URLLoaderDataFormat.BINARY;
urlLoader.addEventListener(Event.COMPLETE,loaderComplete);
urlLoader.load(new URLRequest(&amp;quot;asset/test.xatf&amp;quot;));

function loaderComplete(e:Event):void{
	var bytes:ByteArray = urlLoader.data;
	var xmlLength:int;
	var xmlBytes:ByteArray = new ByteArray();
	var atfBytes:ByteArray = new ByteArray();
	
	bytes.position = bytes.length - 2;
	xmlLength = bytes.readShort();
	
	bytes.position = bytes.length - xmlLength - 2;
	bytes.readBytes(xmlBytes,0,xmlLength);
	
	bytes.position = 0;
	bytes.readBytes(atfBytes,0,bytes.length - xmlLength - 2);
	
	if(AtfData.isAtfData(atfBytes)){
		var texture:Texture = Texture.fromAtfData(atfBytes,2,false,null);
		var textureAlats:TextureAtlas = new TextureAtlas(texture,XML(xmlBytes));
	}
}&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id='id53'&gt;&lt;a href='http://zmliu.github.io/2013/12/17/StarlingSwfToolUpdate/'&gt;程序及源码下载&lt;/a&gt;&lt;/h4&gt;</description>
                <link>http://zmliu.github.io/2013/08/31/ATFTool</link>
                <guid>http://zmliu.github.io/2013/08/31/ATFTool</guid>
                <pubDate>2013-08-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ATF (Adobe Texture Format)</title>
                <description>&lt;h2 id='gpu'&gt;各个平台的GPU处理格式&lt;/h2&gt;
&lt;table class='table table-hover table-bordered'&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th&gt;平台&lt;/th&gt;&lt;th&gt;格式&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;ImgTech (IOS)&lt;/td&gt;&lt;td&gt;PVRTC&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Qualcom (Android)&lt;/td&gt;&lt;td&gt;ETC1&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Mali (Android)&lt;/td&gt;&lt;td&gt;ETC1&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;NVidia (Android)&lt;/td&gt;&lt;td&gt;ETC1/DXT1/DXT5&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Android (PowerVR)&lt;/td&gt;&lt;td&gt;PVRT/ETC1&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Windows&lt;/td&gt;&lt;td&gt;DXT1/DXT5&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;MacOS&lt;/td&gt;&lt;td&gt;DXT1/DXT5&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id='id46'&gt;如何使用工具&lt;/h2&gt;

&lt;p&gt;把工具和原格式图片文件放置在同一文件夹下，例子中使用C盘根目录，DOS使用工具指令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//package leaf.png with all 3 formats (DXT5, PVRTC and ETC1x2)
C:\png2atf.exe -c -i leaf.png -o leaf.atf
[In 213KB][Out 213KB][Ratio 99.9703%][LZMA:0KB JPEG-XR:213KB]

//package specific range of mipmaps
C:\png2atf.exe -c -n 0,5 -i leaf.png -o leaf0,5.atf
[In 213KB][Out 213KB][Ratio 99.8825%][LZMA:0KB JPEG-XR:213KB]

//package only DXT format
C:\png2atf.exe -c d -i leaf.png -o leaf_dxt5.atf
[In 85KB][Out 85KB][Ratio 100.045%][LZMA:0KB JPEG-XR:85KB]

//package only ETC1 format
C:\png2atf.exe -c e -i leaf.png -o leaf_etc1.atf
[In 85KB][Out 85KB][Ratio 100.045%][LZMA:0KB JPEG-XR:85KB]

//package only PVRTC format
C:\png2atf.exe -c p -i leaf.png -o leaf_pvrtc.atf
[In 42KB][Out 42KB][Ratio 100.089%][LZMA:0KB JPEG-XR:42KB]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想在你的ATF存储未压缩的纹理，只要不使用-c参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//package as uncompressed (RGBA) format
C:\png2atf.exe  -i  leaf.png  -o  leaf_rgba.atf
[In 341KB][Out 43KB][Ratio 12.8596%][LZMA:0KB JPEG-XR:43KB]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个很酷的功能是，流式纹理的ATF也可以使用，你可以这样做以生成3个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;png2atf -m -n 0,0 -c -i cubecat0.png -o cubecat_c_high.atf
png2atf -m -n 1,2 -c -i cubecat0.png -o cubecat_c_med.atf
png2atf -m -n 3,20 -c -i cubecat0.png -o cubecat_c_low.atf&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id47'&gt;在&lt;code&gt;Stage3D&lt;/code&gt;中使用压缩纹理&lt;/h2&gt;

&lt;p&gt;你需要使用Texture.uploadCompressedTextureFromByteArray 这个方法来上传压缩纹理，这个API可以设定该压缩纹理是否使用透明通：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Example 
{
 [Embed( source = &amp;quot;mytexture.atf&amp;quot;, mimeType=&amp;quot;application/octet-stream&amp;quot;)]
 public static const TextureAsset:Class;
 public var context3D:Context3D;
 public function init():void
 {
  var texture:Texture = context3D.createTexture(256, 256, 
     Context3DTextureFormat.COMPRESSED_ALPHA, false);
  var textureAsset:ByteArray = new TextureAsset() as ByteArray;
  texture.uploadCompressedTextureFromByteArray(textureAsset, 0);
 }
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;立方体纹理你可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var texCubemap:CubeTexture = context3D.createCubeTexture(256, Context3DTextureFormat.COMPRESSED_ALPHA, false);
var textureAsset:ByteArray = new TextureAsset() as ByteArray;
texCubemap.uploadCompressedTextureFromByteArray(textureAsset, 0);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，根据是否使用透明通道，必须在的片段着色器里使用下面的设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、普通的纹理 Context3DTextureFormat.BGRA
2、“DXT1”（没有透明通道的压缩纹理）Context3DTextureFormat.COMPRESSED
3、“DXT5”（拥有透明通道的压缩纹理）Context3DTextureFormat.COMPRESSED_ALPHA&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id48'&gt;在&lt;code&gt;Starling&lt;/code&gt;中的用法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[Embed(source=&amp;quot;starling.atf&amp;quot;, mimeType=&amp;quot;application/octet-stream&amp;quot;)]
public static const CompressedData:Class;

var data:ByteArray = new CompressedData();
var texture:Texture = Texture.fromAtfData(data);
var image:Image = new Image(texture);
addChild(image);&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id49'&gt;使用要求&lt;/h2&gt;

&lt;p&gt;如果你使用ATF纹理，那么你需要注意下面几点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、如果您使用是`starling`，你至少需要`1.2`版本。在`[Github](https://github.com/PrimaryFeather/Starling-Framework)`上获取，或者官方下载最新版本。
2、如果你是自己封装`Stage3D`，那么你需要使用最新的`AGALMiniAssembler`
3、你至少需要`AIR SDK 3.4` ，或者下载`Flash Builder 4.7AIR 3.4 SDK`。
4、需要Flash播放器`11.4/AIR 3.4`
5、您需要添加编译器参数`“-swf-version=17”`&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id50'&gt;命令说明:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;-i	指定需要转换的文件名
-o	指定输出的文件名
-c	是否压缩。如果不压缩不要填写该参数即可
-q &amp;lt;0-180&amp;gt;	压缩质量越低质量越高
-r	是否使用JPEG-XR+LZMA压缩以减少文件大小 
-n &amp;lt;start,end&amp;gt;	生成mip的等级

例子 png2atf -c -r -q 0 -n 0,1 -i ui.png -o ui.atf&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://zmliu.github.io/2013/08/30/ATF</link>
                <guid>http://zmliu.github.io/2013/08/30/ATF</guid>
                <pubDate>2013-08-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>SFS2X 破解</title>
                <description>&lt;h4 id='id43'&gt;把&lt;code&gt;sfs2x/lib&lt;/code&gt;下的所有&lt;code&gt;jar&lt;/code&gt;库放在构建路径中&lt;/h4&gt;

&lt;h4 id='id44'&gt;代码如下&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;import java.io.FileOutputStream;

import com.smartfoxserver.v2.entities.data.SFSObject;
import com.smartfoxserver.v2.protocol.binary.DefaultPacketCompressor;

public class main {

        public static void main(String[] args) throws Exception {
                SFSObject license = new SFSObject();
                license.putUtfString(&amp;quot;customer&amp;quot;, &amp;quot;&amp;quot;);// 授权人，为空则为共享版，否则个人版
                license.putUtfString(&amp;quot;bind&amp;quot;, &amp;quot;127.0.0.1&amp;quot;);// 限制IP
                license.putInt(&amp;quot;users&amp;quot;, -1);// 连接数上限，-1为无限数量
                license.putLong(&amp;quot;expire&amp;quot;, 0);// 版权到期时间，0为无限制
                license.putBool(&amp;quot;private&amp;quot;, false);// 私有？

                byte[] objectBytes = license.toBinary();
                objectBytes = new DefaultPacketCompressor().compress(objectBytes);
                byte[] licenseData = new byte[objectBytes.length + 4];
                for (int i = 0; i &amp;lt; objectBytes.length; i++) {
                        licenseData[i + 4] = (byte) (objectBytes[i] ^ licenseData[2]);
                }

                new FileOutputStream(&amp;quot;license.2x&amp;quot;).write((byte[]) licenseData);
        }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='id45'&gt;最后将生成的&lt;code&gt;license.2x&lt;/code&gt;文件放在&lt;code&gt;SFS2X/config/&lt;/code&gt;下即可&lt;/h4&gt;</description>
                <link>http://zmliu.github.io/2013/08/29/sfs2x%E7%A0%B4%E8%A7%A3</link>
                <guid>http://zmliu.github.io/2013/08/29/sfs2x破解</guid>
                <pubDate>2013-08-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>最小化时关闭程序</title>
                <description>&lt;pre&gt;&lt;code&gt;如果想在最小化的时候关闭，安卓里可以用NativeApplication.application.exit()
这个方法在iOS里不起作用，iOS里需要在XML里写
&amp;lt;key&amp;gt;
	UIApplicationExitsOnSuspend
&amp;lt;/key&amp;gt;
&amp;lt;true/&amp;gt;&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://zmliu.github.io/2013/08/28/%E6%9C%80%E5%B0%8F%E5%8C%96%E6%97%B6%E5%85%B3%E9%97%AD%E7%A8%8B%E5%BA%8F</link>
                <guid>http://zmliu.github.io/2013/08/28/最小化时关闭程序</guid>
                <pubDate>2013-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>StageWebView 用法</title>
                <description>&lt;h4 id='_airplayer'&gt;&lt;code&gt;StageWebView&lt;/code&gt; 只能再Air中使用。Player中不能使用&lt;/h4&gt;

&lt;h4 id='id39'&gt;代码&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var stagewebview:StageWebView = new StageWebView();
stagewebview.loadURL(&amp;quot;http://www.baidu.com&amp;quot;);
stagewebview.viewPort = new Rectangle(0,0,stage.fullScreenWidth,stage.fullScreenHeight);
stagewebview.stage = stage;&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='xml'&gt;xml配置&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;renderMode&amp;gt;cpu&amp;lt;/renderMode&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='id40'&gt;参考连接&lt;/h4&gt;

&lt;h4 id='httphelpadobecomzh_cnas3devws901d38e593cd1bac3ef1d28412ac57b094b8000html'&gt;&lt;a href='http://help.adobe.com/zh_CN/as3/dev/WS901d38e593cd1bac3ef1d28412ac57b094b-8000.html'&gt;http://help.adobe.com/zh_CN/as3/dev/WS901d38e593cd1bac3ef1d28412ac57b094b-8000.html&lt;/a&gt;&lt;/h4&gt;</description>
                <link>http://zmliu.github.io/2013/08/28/actionscript3</link>
                <guid>http://zmliu.github.io/2013/08/28/actionscript3</guid>
                <pubDate>2013-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>iphone5 Stage 尺寸问题</title>
                <description>&lt;h4 id='adobeair_'&gt;今天用AdobeAir 实现的程序上&lt;code&gt;iTouch5&lt;/code&gt;测试发现尺寸怎么获取出来都是&lt;code&gt;960*640&lt;/code&gt;&lt;/h4&gt;

&lt;h4 id='_'&gt;然后细细回味了一下之前的程序 貌似没有遇到这个问题。&lt;/h4&gt;

&lt;h4 id='_ok'&gt;仔细对比了一下工程和之前工程的差别。发现唯一就是没有&lt;code&gt;icon图&lt;/code&gt;和&lt;code&gt;启动图像&lt;/code&gt;。果断添加了&lt;code&gt;Default-568h@2x.png启动图像&lt;/code&gt; 再次测试OK了&lt;/h4&gt;</description>
                <link>http://zmliu.github.io/2013/08/22/actionscript3</link>
                <guid>http://zmliu.github.io/2013/08/22/actionscript3</guid>
                <pubDate>2013-08-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>nginx 413 Request Entity Too Large</title>
                <description>&lt;pre&gt;&lt;code&gt;该错误是由于 nginx.conf 中 client_max_body_size 的相关设置值太小的原因导致，调整到相应的值即可.
如果运行的是php需要需要注意php.ini的中post_max_size和upload_max_filesize的值.
client_max_body_size需要比post_max_size和upload_max_filesize中的最大值 一致或者稍大&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://zmliu.github.io/2013/08/20/nginx413</link>
                <guid>http://zmliu.github.io/2013/08/20/nginx413</guid>
                <pubDate>2013-08-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>wdlinux lanmp一键包安装使用心得</title>
                <description>&lt;h5 id='wdlinux'&gt;官网:&lt;a href='http://www.wdlinux.cn'&gt;wdlinux&lt;/a&gt;&lt;/h5&gt;

&lt;h5 id='lanmp__'&gt;一键包地址:&lt;a href='http://www.wdlinux.cn/lanmp/'&gt;lanmp&lt;/a&gt; 官网的最新版不是很稳定 所以还是使用这个&lt;/h5&gt;

&lt;h3 id='id37'&gt;安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;如果没有GCC或编译环境,先执行
yum install -y gcc gcc-c++ make autoconf libtool-ltdl-devel gd-devel freetype-devel libxml2-devel libjpeg-devel libpng-devel openssl-devel curl-devel patch libmcrypt-devel libmhash-devel ncurses-devel sudo bzip2 

wget http://dl.wdlinux.cn:5180/lanmp_laster.tar.gz
tar zxvf lanmp_laster.tar.gz
sh in.sh&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='php'&gt;PHP扩展&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;php.ini extension_dir = &amp;quot;./&amp;quot;为#extension_dir = &amp;quot;./&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='wdcp_mysql___innodb'&gt;wdcp mysql 优化方案 - innodb&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;需要先安装 mysql innodb
安装方法
wget -c http://down.wdlinux.cn/in/mysql_innodb_ins.sh
chmod 755 mysql_innodb_ins.sh 
./mysql_innodb_ins.sh&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='_'&gt;相关服务的操作 命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;service wdapache start|stop|restart  wdcp后台
service nginxd start|stop|restart       nginx服务
service httpd start|stop|restart         httpd服务
service pureftpd start|stop|restart    ftp服务
service mysqld start|stop|restart       mysql服务&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='ftp'&gt;ftp&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;如果ftp要访问/www/web以外的其他目录
需要使用
chown -R www 目录名
给予wwww用户xxx目录的操作权限
但是千万不要使用chown -R www / 会把服务器环境搞崩溃
例如需要/home的操作权限 执行命令 chown -R www /home&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id='lnampwdcp'&gt;关于一键安装包，目录，启动，lnamp,wdcp所用端口的说明&lt;/h5&gt;

&lt;h5 id='httpwwwwdlinuxcnbbsthread19211html'&gt;&lt;a href='http://www.wdlinux.cn/bbs/thread-192-1-1.html'&gt;http://www.wdlinux.cn/bbs/thread-192-1-1.html&lt;/a&gt;&lt;/h5&gt;

&lt;h5 id='mysql'&gt;mysql数据迁移&lt;/h5&gt;

&lt;h5 id='httpwwwwdlinuxcnbbsthread152111html'&gt;&lt;a href='http://www.wdlinux.cn/bbs/thread-1521-1-1.html'&gt;http://www.wdlinux.cn/bbs/thread-1521-1-1.html&lt;/a&gt;&lt;/h5&gt;

&lt;h5 id='id38'&gt;常见问题&lt;/h5&gt;

&lt;h5 id='httpwwwwdlinuxcnbbsthread145011html'&gt;&lt;a href='http://www.wdlinux.cn/bbs/thread-1450-1-1.html'&gt;http://www.wdlinux.cn/bbs/thread-1450-1-1.html&lt;/a&gt;&lt;/h5&gt;

&lt;h5 id='php'&gt;PHP升级脚本&lt;/h5&gt;

&lt;h5 id='53httpwwwwdlinuxcnbbsthread373711html'&gt;5.3&lt;a href='http://www.wdlinux.cn/bbs/thread-3737-1-1.html'&gt;http://www.wdlinux.cn/bbs/thread-3737-1-1.html&lt;/a&gt;&lt;/h5&gt;

&lt;h5 id='54httpwwwwdlinuxcnbbsthread477112html'&gt;5.4&lt;a href='http://www.wdlinux.cn/bbs/thread-4771-1-2.html'&gt;http://www.wdlinux.cn/bbs/thread-4771-1-2.html&lt;/a&gt;&lt;/h5&gt;</description>
                <link>http://zmliu.github.io/2013/08/14/wdlinux-lanmp</link>
                <guid>http://zmliu.github.io/2013/08/14/wdlinux-lanmp</guid>
                <pubDate>2013-08-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>MySQL配置文件my.cnf详解</title>
                <description>&lt;p&gt;此mysql配置文件例子针对4G内存&lt;/p&gt;

&lt;h2 id='id1'&gt;&lt;code&gt;port = 3306&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mysql使用的端口&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2'&gt;&lt;code&gt;socket = /tmp/mysqls.sock&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;socket连接文件&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id3'&gt;&lt;code&gt;back_log = 50&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;back_log 是操作系统在监听队列中所能保持的连接数,
队列保存了在MySQL连接管理器线程处理之前的连接.
如果你有非常高的连接率并且出现&amp;quot;connection refused&amp;quot; 报错,
你就应该增加此处的值.
检查你的操作系统文档来获取这个变量的最大值.
如果将back_log设定到比你操作系统限制更高的值,将会没有效果&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id4'&gt;&lt;code&gt;#skip-networking&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;不在TCP/IP端口上进行监听.
如果所有的进程都是在同一台服务器连接到本地的mysqld,
这样设置将是增强安全的方法
所有mysqld的连接都是通过Unix sockets 或者命名管道进行的.
注意在windows下如果没有打开命名管道选项而只是用此项
(通过 &amp;quot;enable-named-pipe&amp;quot; 选项) 将会导致mysql服务没有任何作用!&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id5'&gt;&lt;code&gt;max_connect_errors = 10&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;MySQL 服务所允许的同时会话数的上限
其中一个连接将被SUPER权限保留作为管理员登录.
即便已经达到了连接数的上限.
max_connections = 100
每个客户端连接最大的错误允许数量,如果达到了此限制.
这个客户端将会被MySQL服务阻止直到执行了&amp;quot;FLUSH HOSTS&amp;quot; 或者服务重启
非法的密码以及其他在链接时的错误会增加此值.
查看 &amp;quot;Aborted_connects&amp;quot; 状态来获取全局计数器.&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id6'&gt;&lt;code&gt;table_cache = 2048&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;所有线程所打开表的数量.
增加此值就增加了mysqld所需要的文件描述符的数量
这样你需要确认在[mysqld_safe]中 &amp;quot;open-files-limit&amp;quot; 变量设置打开文件数量允许至少4096&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id7'&gt;&lt;code&gt;#external-locking&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;允许外部文件级别的锁. 打开文件锁会对性能造成负面影响
所以只有在你在同样的文件上运行多个数据库实例时才使用此选项(注意仍会有其他约束!)
或者你在文件层面上使用了其他一些软件依赖来锁定MyISAM表&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id8'&gt;&lt;code&gt;max_allowed_packet = 16M&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;服务所能处理的请求包的最大大小以及服务所能处理的最大的请求大小(当与大的BLOB字段一起工作时相当必要)
每个连接独立的大小.大小动态增加&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id9'&gt;&lt;code&gt;binlog_cache_size = 1M&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;在一个事务中binlog为了记录SQL状态所持有的cache大小
如果你经常使用大的,多声明的事务,你可以增加此值来获取更大的性能.
所有从事务来的状态都将被缓冲在binlog缓冲中然后在提交后一次性写入到binlog中
如果事务比此值大, 会使用磁盘上的临时文件来替代.
此缓冲在每个连接的事务第一次更新状态时被创建&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id10'&gt;&lt;code&gt;max_heap_table_size = 64M&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;独立的内存表所允许的最大容量.
此选项为了防止意外创建一个超大的内存表导致永尽所有的内存资源.&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id11'&gt;&lt;code&gt;sort_buffer_size = 8M&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;排序缓冲被用来处理类似ORDER BY以及GROUP BY队列所引起的排序
如果排序后的数据无法放入排序缓冲,
一个用来替代的基于磁盘的合并分类会被使用
查看 &amp;quot;Sort_merge_passes&amp;quot; 状态变量.
在排序发生时由每个线程分配&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id12'&gt;&lt;code&gt;join_buffer_size = 8M&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;此缓冲被使用来优化全联合(full JOINs 不带索引的联合).
类似的联合在极大多数情况下有非常糟糕的性能表现,
但是将此值设大能够减轻性能影响.
通过 &amp;quot;Select_full_join&amp;quot; 状态变量查看全联合的数量
当全联合发生时,在每个线程中分配&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id13'&gt;&lt;code&gt;thread_cache_size = 8&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;我们在cache中保留多少线程用于重用
当一个客户端断开连接后,如果cache中的线程还少于thread_cache_size,
则客户端线程被放入cache中.
这可以在你需要大量新连接的时候极大的减少线程创建的开销
(一般来说如果你有好的线程模型的话,这不会有明显的性能提升.)&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id14'&gt;&lt;code&gt;thread_concurrency = 8&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;此允许应用程序给予线程系统一个提示在同一时间给予渴望被运行的线程的数量.
此值只对于支持 thread_concurrency() 函数的系统有意义( 例如Sun Solaris).
你可可以尝试使用 [CPU数量]*(2..4) 来作为thread_concurrency的值&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id15'&gt;&lt;code&gt;query_cache_size = 64M&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;查询缓冲常被用来缓冲 SELECT 的结果并且在下一次同样查询的时候不再执行直接返回结果.
打开查询缓冲可以极大的提高服务器速度, 如果你有大量的相同的查询并且很少修改表.
查看 &amp;quot;Qcache_lowmem_prunes&amp;quot; 状态变量来检查是否当前值对于你的负载来说是否足够高.
注意: 在你表经常变化的情况下或者如果你的查询原文每次都不同,
查询缓冲也许引起性能下降而不是性能提升.&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id16'&gt;&lt;code&gt;query_cache_limit = 2M&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;只有小于此设定值的结果才会被缓冲
此设置用来保护查询缓冲,防止一个极大的结果集将其他所有的查询结果都覆盖.&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id17'&gt;&lt;code&gt;ft_min_word_len = 4&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;被全文检索索引的最小的字长.
你也许希望减少它,如果你需要搜索更短字的时候.
注意在你修改此值之后,
你需要重建你的 FULLTEXT 索引&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id18'&gt;&lt;code&gt;#memlock&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;如果你的系统支持 memlock() 函数,你也许希望打开此选项用以让运行中的mysql在在内存高度紧张的时候,数据在内存中保持锁定并且防止可能被swapping out
此选项对于性能有益&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id19'&gt;&lt;code&gt;default_table_type = MYISAM&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;当创建新表时作为默认使用的表类型,
如果在创建表示没有特别执行表类型,将会使用此值&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id20'&gt;&lt;code&gt;thread_stack = 192K&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;线程使用的堆大小. 此容量的内存在每次连接时被预留.
MySQL 本身常不会需要超过64K的内存
如果你使用你自己的需要大量堆的UDF函数
或者你的操作系统对于某些操作需要更多的堆,
你也许需要将其设置的更高一点.&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id21'&gt;&lt;code&gt;transaction_isolation = REPEATABLE-READ&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;设定默认的事务隔离级别.可用的级别如下:
READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id22'&gt;&lt;code&gt;tmp_table_size = 64M&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;内部(内存中)临时表的最大大小
如果一个表增长到比此值更大,将会自动转换为基于磁盘的表.
此限制是针对单个表的,而不是总和.&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id23'&gt;&lt;code&gt;log-bin=mysql-bin&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;打开二进制日志功能.
在复制(replication)配置中,作为MASTER主服务器必须打开此项
如果你需要从你最后的备份中做基于时间点的恢复,你也同样需要二进制日志.&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id24'&gt;&lt;code&gt;#log_slave_updates&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;如果你在使用链式从服务器结构的复制模式 (A-&amp;gt;B-&amp;gt;C),
你需要在服务器B上打开此项.
此选项打开在从线程上重做过的更新的日志,
并将其写入从服务器的二进制日志.&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id25'&gt;&lt;code&gt;#log&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;打开全查询日志. 所有的由服务器接收到的查询 (甚至对于一个错误语法的查询)
都会被记录下来. 这对于调试非常有用, 在生产环境中常常关闭此项.&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id26'&gt;&lt;code&gt;#log_warnings&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;将警告打印输出到错误log文件.  如果你对于MySQL有任何问题
你应该打开警告log并且仔细审查错误日志,查出可能的原因.&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id27'&gt;&lt;code&gt;log_slow_queries&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;记录慢速查询. 慢速查询是指消耗了比 &amp;quot;long_query_time&amp;quot; 定义的更多时间的查询.
如果 log_long_format 被打开,那些没有使用索引的查询也会被记录.
如果你经常增加新查询到已有的系统内的话. 一般来说这是一个好主意,&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id28'&gt;&lt;code&gt;long_query_time = 2&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;所有的使用了比这个时间(以秒为单位)更多的查询会被认为是慢速查询.
不要在这里使用&amp;quot;1&amp;quot;, 否则会导致所有的查询,甚至非常快的查询页被记录下来(由于MySQL 目前时间的精确度只能达到秒的级别).&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id29'&gt;&lt;code&gt;log_long_format&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;在慢速日志中记录更多的信息.
一般此项最好打开.
打开此项会记录使得那些没有使用索引的查询也被作为到慢速查询附加到慢速日志里&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id30'&gt;&lt;code&gt;#tmpdir = /tmp&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;此目录被MySQL用来保存临时文件.例如,
它被用来处理基于磁盘的大型排序,和内部排序一样.
以及简单的临时表.
如果你不创建非常大的临时文件,将其放置到 swapfs/tmpfs 文件系统上也许比较好
另一种选择是你也可以将其放置在独立的磁盘上.
你可以使用&amp;quot;;&amp;quot;来放置多个路径
他们会按照roud-robin方法被轮询使用.&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id31'&gt;&lt;code&gt;server-id = 1&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;唯一的服务辨识号,数值位于 1 到 2^32-1之间.
此值在master和slave上都需要设置.
如果 &amp;quot;master-host&amp;quot; 没有被设置,则默认为1, 但是如果忽略此选项,MySQL不会作为master生效.&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id32'&gt;&lt;code&gt;Slave&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;复制的Slave (去掉master段的注释来使其生效)
#
为了配置此主机作为复制的slave服务器,你可以选择两种方法:
#
1) 使用 CHANGE MASTER TO 命令 (在我们的手册中有完整描述) -
   语法如下:

   CHANGE MASTER TO MASTER_HOST=&amp;lt;host&amp;gt;, MASTER_PORT=&amp;lt;port&amp;gt;,
   MASTER_USER=&amp;lt;user&amp;gt;, MASTER_PASSWORD=&amp;lt;password&amp;gt; ;

   你需要替换掉 &amp;lt;host&amp;gt;, &amp;lt;user&amp;gt;, &amp;lt;password&amp;gt; 等被尖括号包围的字段以及使用master的端口号替换&amp;lt;port&amp;gt; (默认3306).

   例子:

   CHANGE MASTER TO MASTER_HOST=&amp;#39;125.564.12.1&amp;#39;, MASTER_PORT=3306,
   MASTER_USER=&amp;#39;joe&amp;#39;, MASTER_PASSWORD=&amp;#39;secret&amp;#39;;

或者
#
2) 设置以下的变量. 不论如何, 在你选择这种方法的情况下, 然后第一次启动复制(甚至不成功的情况下,
   例如如果你输入错密码在master-password字段并且slave无法连接),
   slave会创建一个 master.info 文件,并且之后任何对于包含在此文件内的参数的变化都会被忽略
   并且由 master.info 文件内的内容覆盖, 除非你关闭slave服务, 删除 master.info 并且重启slave 服务.
   由于这个原因,你也许不想碰一下的配置(注释掉的) 并且使用 CHANGE MASTER TO (查看上面) 来代替

所需要的唯一id号位于 2 和 2^32 - 1之间
(并且和master不同)
如果master-host被设置了.则默认值是2
但是如果省略,则不会生效
#server-id = 2

复制结构中的master - 必须
#master-host = &amp;lt;hostname&amp;gt;

当连接到master上时slave所用来认证的用户名 - 必须
#master-user = &amp;lt;username&amp;gt;

当连接到master上时slave所用来认证的密码 - 必须
#master-password = &amp;lt;password&amp;gt;

master监听的端口.
可选 - 默认是3306
#master-port = &amp;lt;port&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id33'&gt;&lt;code&gt;#read_only&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;使得slave只读.只有用户拥有SUPER权限和在上面的slave线程能够修改数据.
你可以使用此项去保证没有应用程序会意外的修改slave而不是master上的数据&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id34'&gt;&lt;code&gt;quick&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[mysqldump]
不要在将内存中的整个结果写入磁盘之前缓存. 在导出非常巨大的表时需要此项


max_allowed_packet = 16M

[mysql]
no-auto-rehash&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id35'&gt;&lt;code&gt;#safe-updates&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;仅仅允许使用键值的 UPDATEs 和 DELETEs .&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;[isamchk]
key_buffer = 512M
sort_buffer_size = 512M
read_buffer = 8M
write_buffer = 8M

[myisamchk]
key_buffer = 512M
sort_buffer_size = 512M
read_buffer = 8M
write_buffer = 8M

[mysqlhotcopy]
interactive-timeout&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id='id36'&gt;&lt;code&gt;open-files-limit = 8192&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[mysqld_safe]
增加每个进程的可打开文件数量.
警告: 确认你已经将全系统限制设定的足够高!
打开大量表需要将此值设b&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://zmliu.github.io/2013/08/09/mysql-my_cnf</link>
                <guid>http://zmliu.github.io/2013/08/09/mysql-my_cnf</guid>
                <pubDate>2013-08-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Hello World2</title>
                <description>&lt;code class=&quot;java&quot;&gt;再次测试&lt;/code&gt;
</description>
                <link>http://zmliu.github.io/test/2013/08/02/hello-world2</link>
                <guid>http://zmliu.github.io/test/2013/08/02/hello-world2</guid>
                <pubDate>2013-08-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Hello Blog</title>
                <description>测试一下

&lt;a href=&quot;http://zmliu.github.io/2013/12/17/StarlingSwfToolUpdate/&quot; target=&quot;_blank&quot;&gt;http://zmliu.github.io/2013/12/17/StarlingSwfToolUpdate/&lt;/a&gt;
</description>
                <link>http://zmliu.github.io/test/2013/08/02/hello-world</link>
                <guid>http://zmliu.github.io/test/2013/08/02/hello-world</guid>
                <pubDate>2013-08-02T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
